#pragma once
#include "CanOpenMotor.h"
#include "gantry_global_status.h"

/**
    \addtogroup MOTDESC
    <div style="page-break-after: always;"></div>


    \section MOTCARM C-ARM Rotation Description

    ## Abstract 

    This section describes the feature of the C-ARM motor control.
    The section describes in detail the performances, the activation modes, and the limitations.


    ## Overview

    The Gantry provides the C-ARM rotation tool mainly to allow 
    the operator to select a projection for an incoming exposure.

    The projection selection is a mandatory condition to proceed with 
    an exposure (with few exceptions). 

    The only method to select a projection is through the AWS command. 
    (see the AWS protocol documentation \ref EXEC_ArmPosition).

    \note
    Although the projection can be solely selected by the AWS, a manual activation 
    is always permitted for a limited angle range, pressing the manual buttons.

    When the C-ARM is activated in automatic mode the Vertical motor 
    is activated subsequently to keep the height of the patient compression plane unchanged (Virtual Isocentric feature).

    \note
    The Virtual isocentric correction is activated only with the AWS command. The manual position doesn't change the Vertical ARM position.

    The current ARM angle and selected projection is displayed on the Gantry Display.

    A Safety startegy is iplemented in order to prevent accidental activation or impacts.

     
    ## Performances

    The C-ARM is controlled with a precision of 0.01 degree.
    Although such precision, an Automatic activation with the AWS protocol command can only set a target angle 
    with only 1 degree of resolution.

    The C-ARM rotation range is:  -180 to 180.
   
    The actual rotation speed can be changed in the \ref MotorConfig file:
    + The Automatic Acceleration, Deceleration and Speed can be set;
    + The Manual Acceleration, Deceleration and Speed can be set;
    + The Service Acceleration and Speed(for zero setting procedure) can be set;

    ## Position Calibration

    The current position of the C-ARM is provided by an high resolution encoder 
    embedded into the intelligent motor driver:
    + The initial position, after the system power on, is provided by the MCPU that 
    read it from the configuration file;
    + The actual position is then saved into the configuration file after any activation completion;

    In the event of data lost or corrupted position, 
    the correct position can be restored with an automatic or manual calibration procedure:
    + The Automatic calibration position makes use of a zero position photocell;
    + The manual procedure allows to manually move the ARM to the correct zero position;

    \note
    After the first istallation it is mandatory to execute the zero position calibration
    before to make the ARM available for the automatic activations. In this case a WARNING message 
    is generated by the MCPU.


    ## Automatic C-ARM Positioning 

    The AWS can select a target projection with a proper protocol command (\ref EXEC_ArmPosition).

    \note
    The projection selection is mandatory to enable an exposure. 
    After any exposure, the current projection is invalidated and the AWS shall set it ones more in order to proceed
    with a new exposure.

    The Command will set:
    + The projection name;
    + The target Angle;
    + The acceptable position range;

    ### Projection Name 

    The Projection name refers to one of the possible selectable projections:

    PROJECTION FOR 2D|PROJECTION FOR 3D|PROJECTION FOR CESM|PROJECTION FOR COMBO|PROJECTION FOR VI|
    |:--|:--|:--|:--|:--|
    |LCC|LCCT|LCCD|LCCB|LCCM|
    |LFB|LFBT|LFBD|LFBB|LFBM|
    |LISO|LISOT|LISOD|LISOB|LISOM|
    |LLM|LLMT|LLMD|LLMB|LLMM|
    |LLMO|LLMOT|LLMOD|LLMOB|LLMOM|
    |LML|LMLT|LMLD|LMLB|LMLM|
    |LMLO|LMLOT|LMLOD|LMLOB|LMLOM|
    |LSIO|LSIOT|LSIOD|LSIOB|LSIOM|
    |RCC|RCCT|RCCD|RCCB|RCCM|
    |RFB|RFBT|RFBD|RFBB|RFBM|
    |RISO|RISOT|RISOD|RISOB|RISOM|
    |RLM|RLMT|RLMD|RLMB|RLMM|
    |RML|RLMOT|RLMOD|RLMOB|RLMOM|
    |RMLO|RMLT|RMLD|RMLB|RMLM|
    |RSIO|RMLOT|RMLOD|RMLOB|RMLOM|

    \note
    The projection name  shall be one present in a list that the AWS should have previously uploaded into Gantry
    with the command \ref SET_ProjectionList.

    ### Target Angle

    The target angle is the angle where actually the C-ARM shall be rotated.

    The angle is set by the AWS based usually by the ACR views typical angles.

    \note
    The AWS may change the angle associated to a projection name.  
    
    ### Acceptable Range
    
    The acceptable range parameter is set by the AWS so that a manual modification of the C-ARM angle 
    cannot exceed a reasonable value that may loose the meaning of the projection name selected.

    \note
    The operator may move the C-ARM in the full range with the manual button, but when the ARM should be out of 
    the acceptable range, a WARNING message will be activated by the MCPU, preventing the possibilty to start an exposure.

    ### Virtual Isocentric Correction

    Only with an Automatic activation and after the C-ARM rotation completion, the Vertical Motor will adjust (if necessary) 
    the height of the Detector plane in order to keep the compression plane unchanged.

    This feature, called <b>Virtual Isocentricity</b>,  allows the operator to set the right position for the patient 
    one time only for different projections.

    \note
    The Height adjustment can happen only after the C-ARM rotation completion and only 
    if this activation should successfully terminate.

    ### Rotation speed in Automatic mode

    The rotation speed when in automatic mode is set in the \ref MotorConfig.

    \warning
    Although the speed may be changed with the configuration file,
    it is discouraged if the modify is made by a non skilled personel.
    
    
    ## Manual Positioning

    The C-ARM can be activate in manual mode in different scenarios:
    + In operating mode (Open Study contest) two manual buttons are asigned to the CW and CCW rotations;
    + In the manual zero setting service procedure, all the manual buttons and the Pedalboard pedals can activate the rotation
    in CW or CCW;
    + In the service rotation tool , all the manual buttons and the Pedalboard pedals can activate the rotation
    in CW or CCW;

    \note 
    When in manual zero setting procedure, the speed of the rotation is strongly reduced to help 
    the fine ARM positioning to the mechanical zero. 

    \note
    The actual speed of the Manual rotation can be adjuted in the \ref MotorConfig.

    \note
    When in operating mode, the manual rotation shuld be executed only after a valid projection selection.
    Differently, this may be overriden by a further command from the AWS.

    ## Idle Positioning 

    The C-ARM will be activated by the Application in the Idle Sequence, at the end of the sequence, 
    as described in the \ref IDLEDESC.


    ## Zero Setting Calibration

    The zero setting procedure is necessary when:
    + After the first installation in Factory;
    + In case the C-ARM should be mechanically removed or rotated for service;
    + In case the MCPU software should be reinstalled and the \ref MotorConfig should be cancelled or overridden;
    + In case the configuraiton file should be corrupted;

    The missing of the correct C-ARM position cannot be detected by the system automatically
    and may be visible by an evident discrepance from the projection angle and the effective angle.

    In the case a zero setting procedure should be executed, a service tool is provided.

    There are two possible zero setting procedures:
    + The automatic procedure;
    + The manual procedure;

    When the automatic zero setting procedure is activated:
    + The motor driver executes a slow rotation until a photocell intercepts the mechanical zero point;
    + The Internal encoder of the motor is then reset to zero;
    + The \ref MotorConfig file is updated;

    The manual zero setting position, differently by the automatic zero setting procedure,
    requires the manual activation of the C-ARM by pressing one of the enabled buttons.

    The operator shall rotate the C-ARM in this way until the position reaches the expected mechanical zero point:
    + The Internal encoder of the motor is then reset to zero;
    + The \ref MotorConfig file is then updated;

    \note
    the speed in the manual mode is reduced allowing to a fine zero positioning.

    ## Motor Fault Management
    
    The motor driver handles an internal Diagnostics in order to detect malfunctions.

    There are several fault conditions: 
    + some of theme are repristinable;
    + other malfunctions, for theire inner nature, causes a permanent fault;

    In case the Motor driver should detect a fault condition, the MCPU application 
    will activate an ERROR message with the description of the signaled fault.

    \attention
    When the motor driver is in fault condition it internally disables the motor activation.\n
    The MCPU only monitors the status changing and, as soon as the fault condition should  
    reset, it clears the error message.\n
    There is however an exception:
    + if the signaled fault is due to a thermal protection, the MCPU will remove the power to the 
    motor and put the Gantry out of service.


    ## Safety Strategy

    The following safety strategy protects against injuries:
    + In Idle state (not in Open Study) the C-ARM rotation is disabled at all.  
    
    \note
    In Idle state, the Gantry may be left unattended and consequently may be accidentally activated by 
    non competent operators.

    + During a compression, the C-ARM activation is disabled;
    + In case of driver faut, The C-ARM activation is disabled;
    + During an Automatic rotation (AWS) every manual button or pedalboard activation stops the rotation;
    + During an Automatic rotation (AWS) the obstacle detection stops the rotation;
    + A picture with the projection Icon will result well visible on the Screen,
    remembering to the operator what is the current selected projection, and preventing a wrong breast placement;
    + The Acceptable range guarantee the coherence of the C-ARM angle respect the current expected exposure mode;

    ## Motor Configuration process

    During the Application startup fase, after the communication with the motor driver 
    is achieved and before to enter in an operatiing mode (where the motor can be activated),
    the application uploads the motor driver with all the necessary registers in order to 
    tune the motor performances as expected.

    \note
    Not all the registers are modified during the startup: some register is runtime modified 
    when the motor is activated by the application.

    Because the C-ARM module inherits the Base Motor Module,
    most of the registers that this module uploads are the default of the base module.
    See the \ref MOTCONFIG for details

    Here are reported only those registers  that are specific for the C-ARM: 

    |Register Address|Value|Description|
    |:--|:--|:--|
    |0x3210:01|50000| Position Loop, Proportional Gain (closed Loop)|
    |0x3210:02|10| Position Loop, Integral Gain (closed Loop)|


*/ 


/// <summary>
/// \defgroup ArmMotor_Module C-ARM Rotation Module Implementation
/// 
/// \ingroup MOTIMPL 
/// 
/// This module describes the C-ARM rotation implementation.
/// 
/// See the \ref MOTDESC for module functional ldescription details.
/// 
/// </summary>
/// 
///  
///



/// <summary>
/// 
/// \ingroup ArmMotor_Module
/// 
/// This class handles the projection selection process.
/// 
/// </summary>
/// 
/// When the Application should select a projection,
/// the following steps shall be followed:
/// - the requested projection shall be validated;
/// - the requested projection shall be accepted;
/// - the requested projection shall be displayed on the GUI;
/// 
/// This class provides methods and data structures to handle
/// the previous steps.
/// 
/// 
/// 
ref class ProjectionOptions {

public:

    /// <summary>
    /// This is the class constructor.
    /// </summary>
    /// 
    /// When the class is generated, the constructor 
    /// automatically generate the list of projection images.
    /// 
    /// The projection images will be used in order to display the projection Icon 
    /// when selected.
    ///  
    ProjectionOptions() {

        // Initialize the selected projection
        clrProjection();

        // Create a void list
        projection_list = gcnew List<options>();

        ProjectionsIcons = gcnew Dictionary<System::String^, Image^>();
        ProjectionsIcons->Add("", Image::FromFile(Gantry::applicationResourcePath + "Projections\\NO_PROJ.PNG"));
        ProjectionsIcons->Add("UNDEF", Image::FromFile(Gantry::applicationResourcePath + "Projections\\NO_PROJ.PNG"));

        // ----------------------- FFDM SELECTIONS ------------------------------------------------------------------- //
        ProjectionsIcons->Add("LCC", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjFFDM\\LCC.PNG"));
        ProjectionsIcons->Add("LFB", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjFFDM\\LFB.PNG"));
        ProjectionsIcons->Add("LISO", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjFFDM\\LISO.PNG"));
        ProjectionsIcons->Add("LLM", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjFFDM\\LLM.PNG"));
        ProjectionsIcons->Add("LLMO", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjFFDM\\LLMO.PNG"));
        ProjectionsIcons->Add("LML", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjFFDM\\LML.PNG"));
        ProjectionsIcons->Add("LMLO", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjFFDM\\LMLO.PNG"));
        ProjectionsIcons->Add("LSIO", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjFFDM\\LSIO.PNG"));
        ProjectionsIcons->Add("RCC", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjFFDM\\RCC.PNG"));
        ProjectionsIcons->Add("RFB", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjFFDM\\RFB.PNG"));
        ProjectionsIcons->Add("RISO", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjFFDM\\RISO.PNG"));
        ProjectionsIcons->Add("RLM", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjFFDM\\RLM.PNG"));
        ProjectionsIcons->Add("RLMO", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjFFDM\\RLMO.PNG"));
        ProjectionsIcons->Add("RML", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjFFDM\\RML.PNG"));
        ProjectionsIcons->Add("RMLO", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjFFDM\\RMLO.PNG"));
        ProjectionsIcons->Add("RSIO", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjFFDM\\RSIO.PNG"));

        // ----------------------- TOMO SELECTIONS ------------------------------------------------------------------- //       
        ProjectionsIcons->Add("LCCT", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjTOMO\\LCCT.PNG"));
        ProjectionsIcons->Add("LFBT", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjTOMO\\LFBT.PNG"));
        ProjectionsIcons->Add("LISOT", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjTOMO\\LISOT.PNG"));
        ProjectionsIcons->Add("LLMT", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjTOMO\\LLMT.PNG"));
        ProjectionsIcons->Add("LLMOT", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjTOMO\\LLMOT.PNG"));
        ProjectionsIcons->Add("LMLT", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjTOMO\\LMLT.PNG"));
        ProjectionsIcons->Add("LMLOT", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjTOMO\\LMLOT.PNG"));
        ProjectionsIcons->Add("LSIOT", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjTOMO\\LSIOT.PNG"));
        ProjectionsIcons->Add("RCCT", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjTOMO\\RCCT.PNG"));
        ProjectionsIcons->Add("RFBT", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjTOMO\\RFBT.PNG"));
        ProjectionsIcons->Add("RISOT", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjTOMO\\RISOT.PNG"));
        ProjectionsIcons->Add("RLMT", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjTOMO\\RLMT.PNG"));
        ProjectionsIcons->Add("RLMOT", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjTOMO\\RLMOT.PNG"));
        ProjectionsIcons->Add("RMLT", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjTOMO\\RMLT.PNG"));
        ProjectionsIcons->Add("RMLOT", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjTOMO\\RMLOT.PNG"));
        ProjectionsIcons->Add("RSIOT", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjTOMO\\RSIOT.PNG"));

        // ----------------------- CESM SELECTIONS ------------------------------------------------------------------- //       
        ProjectionsIcons->Add("LCCD", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjCESM\\LCCD.PNG"));
        ProjectionsIcons->Add("LFBD", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjCESM\\LFBD.PNG"));
        ProjectionsIcons->Add("LISOD", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjCESM\\LISOD.PNG"));
        ProjectionsIcons->Add("LLMD", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjCESM\\LLMD.PNG"));
        ProjectionsIcons->Add("LLMOD", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjCESM\\LLMOD.PNG"));
        ProjectionsIcons->Add("LMLD", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjCESM\\LMLD.PNG"));
        ProjectionsIcons->Add("LMLOD", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjCESM\\LMLOD.PNG"));
        ProjectionsIcons->Add("LSIOD", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjCESM\\LSIOD.PNG"));
        ProjectionsIcons->Add("RCCD", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjCESM\\RCCD.PNG"));
        ProjectionsIcons->Add("RFBD", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjCESM\\RFBD.PNG"));
        ProjectionsIcons->Add("RISOD", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjCESM\\RISOD.PNG"));
        ProjectionsIcons->Add("RLMD", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjCESM\\RLMD.PNG"));
        ProjectionsIcons->Add("RLMOD", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjCESM\\RLMOD.PNG"));
        ProjectionsIcons->Add("RMLD", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjCESM\\RMLD.PNG"));
        ProjectionsIcons->Add("RMLOD", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjCESM\\RMLOD.PNG"));
        ProjectionsIcons->Add("RSIOD", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjCESM\\RSIOD.PNG"));

        // ----------------------- COMBO SELECTIONS ------------------------------------------------------------------- //       
        ProjectionsIcons->Add("LCCB", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjCOMBO\\LCCB.PNG"));
        ProjectionsIcons->Add("LFBB", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjCOMBO\\LFBB.PNG"));
        ProjectionsIcons->Add("LISOB", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjCOMBO\\LISOB.PNG"));
        ProjectionsIcons->Add("LLMB", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjCOMBO\\LLMB.PNG"));
        ProjectionsIcons->Add("LLMOB", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjCOMBO\\LLMOB.PNG"));
        ProjectionsIcons->Add("LMLB", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjCOMBO\\LMLB.PNG"));
        ProjectionsIcons->Add("LMLOB", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjCOMBO\\LMLOB.PNG"));
        ProjectionsIcons->Add("LSIOB", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjCOMBO\\LSIOB.PNG"));
        ProjectionsIcons->Add("RCCB", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjCOMBO\\RCCB.PNG"));
        ProjectionsIcons->Add("RFBB", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjCOMBO\\RFBB.PNG"));
        ProjectionsIcons->Add("RISOB", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjCOMBO\\RISOB.PNG"));
        ProjectionsIcons->Add("RLMB", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjCOMBO\\RLMB.PNG"));
        ProjectionsIcons->Add("RLMOB", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjCOMBO\\RLMOB.PNG"));
        ProjectionsIcons->Add("RMLB", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjCOMBO\\RMLB.PNG"));
        ProjectionsIcons->Add("RMLOB", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjCOMBO\\RMLOB.PNG"));
        ProjectionsIcons->Add("RSIOB", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjCOMBO\\RSIOB.PNG"));
      
        // ----------------------- VI SELECTIONS ------------------------------------------------------------------- //       
        ProjectionsIcons->Add("LCCM", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjVI\\LCCM.PNG"));
        ProjectionsIcons->Add("LFBM", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjVI\\LFBM.PNG"));
        ProjectionsIcons->Add("LISOM", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjVI\\LISOM.PNG"));
        ProjectionsIcons->Add("LLMM", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjVI\\LLMM.PNG"));
        ProjectionsIcons->Add("LLMOM", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjVI\\LLMOM.PNG"));
        ProjectionsIcons->Add("LMLM", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjVI\\LMLM.PNG"));
        ProjectionsIcons->Add("LMLOM", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjVI\\LMLOM.PNG"));
        ProjectionsIcons->Add("LSIOM", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjVI\\LSIOM.PNG"));
        ProjectionsIcons->Add("RCCM", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjVI\\RCCM.PNG"));
        ProjectionsIcons->Add("RFBM", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjVI\\RFBM.PNG"));
        ProjectionsIcons->Add("RISOM", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjVI\\RISOM.PNG"));
        ProjectionsIcons->Add("RLMM", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjVI\\RLMM.PNG"));
        ProjectionsIcons->Add("RLMOM", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjVI\\RLMOM.PNG"));
        ProjectionsIcons->Add("RMLM", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjVI\\RMLM.PNG"));
        ProjectionsIcons->Add("RMLOM", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjVI\\RMLOM.PNG"));
        ProjectionsIcons->Add("RSIOM", Image::FromFile(Gantry::applicationResourcePath + "Projections\\prjVI\\RSIOM.PNG"));
    }

    /// <summary>
    ///  This is the enumeration option code of the selectable projections.
    /// 
    /// 
    /// The code value represent the related icon path in the icon path list
    /// pointed by ProjectionsIcons.
    /// </summary>
    enum class options {
        LCC = 0,
        LFB,
        LISO,
        LLM,
        LLMO,
        LML,
        LMLO,
        LSIO,
        RCC,
        RFB,
        RISO,
        RLM,
        RLMO,
        RML,
        RMLO,
        RSIO,

        LCCT,
        LFBT,
        LISOT,
        LLMT,
        LLMOT,
        LMLT,
        LMLOT,
        LSIOT,
        RCCT,
        RFBT,
        RISOT,
        RLMT,
        RLMOT,
        RMLT,
        RMLOT,
        RSIOT,

        LCCD,
        LFBD,
        LISOD,
        LLMD,
        LLMOD,
        LMLD,
        LMLOD,
        LSIOD,
        RCCD,
        RFBD,
        RISOD,
        RLMD,
        RLMOD,
        RMLD,
        RMLOD,
        RSIOD,

        LCCB,
        LFBB,
        LISOB,
        LLMB,
        LLMOB,
        LMLB,
        LMLOB,
        LSIOB,
        RCCB,
        RFBB,
        RISOB,
        RLMB,
        RLMOB,
        RMLB,
        RMLOB,
        RSIOB,

        LCCM,
        LFBM,
        LISOM,
        LLMM,
        LLMOM,
        LMLM,
        LMLOM,
        LSIOM,
        RCCM,
        RFBM,
        RISOM,
        RLMM,
        RLMOM,
        RMLM,
        RMLOM,
        RSIOM,

        LEN,
        UNDEF = LEN,
        RESERVED_FOR_INIT
    };

    /// <summary>
    /// This is a string array used to get a string name of the icon tag.
    /// </summary>
    static const cli::array<System::String^>^ tags = gcnew cli::array<System::String^> {
        "LCC", "LFB", "LISO", "LLM", "LLMO", "LML", "LMLO", "LSIO", "RCC", "RFB", "RISO", "RLM", "RLMO", "RML", "RMLO", "RSIO",
         "LCCT", "LFBT", "LISOT", "LLMT", "LLMOT", "LMLT", "LMLOT", "LSIOT", "RCCT", "RFBT", "RISOT", "RLMT", "RLMOT", "RMLT", "RMLOT", "RSIOT",
         "LCCD", "LFBD", "LISOD", "LLMD", "LLMOD", "LMLD", "LMLOD", "LSIOD", "RCCD", "RFBD", "RISOD", "RLMD", "RLMOD", "RMLD", "RMLOD", "RSIOD",
         "LCCB", "LFBB", "LISOB", "LLMB", "LLMOB", "LMLB", "LMLOB", "LSIOB", "RCCB", "RFBB", "RISOB", "RLMB", "RLMOB", "RMLB", "RMLOB", "RSIOB",
         "LCCM", "LFBM", "LISOM", "LLMM", "LLMOM", "LMLM", "LMLOM", "LSIOM", "RCCM", "RFBM", "RISOM", "RLMM", "RLMOM", "RMLM", "RMLOM", "RSIOM",
        "UNDEF"
    };

    /// <summary>
    /// This function returns the projection code from the related string name.
    /// </summary>
    /// <param name="tg">The string name of the requested projection code</param>
    /// <returns>The projection code</returns>
    static options getCode(System::String^ tg) {
        for (int i = 0; i < (int)options::LEN; i++) {
            if (tags[i] == tg) return (options)i;
        }
        return options::UNDEF;
    }

    /// <summary>
    /// This function populates the list of the acceptable projections.
    /// </summary>
    /// <param name="list">This is a new list of acceptable projections</param>
    /// <returns>
    /// + true: the list is valid;
    /// + false: the list is not valid
    /// </returns>
    bool setList(List<System::String^>^ list) {
        projection_list->Clear();

        for (int i = 0; i < list->Count; i++) {
            options code = getCode(list[i]);
            if (code == options::UNDEF) {
                projection_list->Clear();
                return false;
            }
            projection_list->Add(code);
        }
        return true;
    }

    /// <summary>
    /// This function clears the acceptable list.
    /// </summary>
    /// 
    /// \note
    /// when the acceptable list is cleared, no more 
    /// projection selection can be accepted by this module.
    /// 
    /// <param name=""></param>
    void clrList(void) {
        projection_list->Clear();
    }


    /// <summary>
    /// This function clears the current selected projection.
    /// </summary>
    /// <param name=""></param>
    void clrProjection(void) {
        current_projection_code = options::UNDEF;
        current_projection_name = tags[(int)current_projection_code];
    }

    /// <summary>
    /// This function check if the named projection is present in the acceptable projection list.
    /// </summary>
    /// <param name="tag"></param>
    /// <returns></returns>
    bool isValidProjection(System::String^ tag) {
        for (int i = 0; i < (int)options::UNDEF; i++) {
            if (tags[i] == tag) {
                if (projection_list->Contains((options)i)) return true;
                else return false;
            }
        }
        return false;
    }

    /// <summary>
    /// This function select a given projection from the string name of the projection
    /// </summary>
    /// <param name="tag">string name of the projection</param>
    /// <returns>true: the projection is valid;\nfalse: the projection is invalid</returns>
    bool setProjection(System::String^ tag) {
        for (int i = 0; i < (int)options::UNDEF; i++) {
            if (tags[i] == tag) return setProjection((options)i);
        }
        return false;
    }

    
    /// <summary>
    /// This function select a given projection from the projection code
    /// </summary>
    /// <param name="code">the code of the selecting projection</param>
    /// <returns>
    /// + true: the projection is valid;
    /// + false: the projection is invalid
    /// </returns>
    bool setProjection(options code) {
        if ((int)code >= (int)options::UNDEF) return false;
        if (!projection_list->Contains(code)) return false;
        current_projection_code = code;
        current_projection_name = tags[(int)code];
        return true;
    }

    
    /// <summary>
    /// This function returns the projection name currently selected
    /// </summary>
    /// <param name=""></param>
    /// <returns>the current selected projection name</returns>
    System::String^ getCurrentProjectionName(void) { return current_projection_name; }

    /// <summary>
    /// This function returns the projection code currently selected
    /// </summary>
    /// <param name=""></param>
    /// <returns>the current selected projection code</returns>
    options getCurrentProjectionCode(void) { return current_projection_code; }

    /// <summary>
    /// This function returns the Image block of the selected projection
    /// </summary>
    /// <param name=""></param>
    /// <returns>The Image of the selected projection</returns>
    Image^ getCurrentProjectionIcon(void) { return ProjectionsIcons[current_projection_name]; }
    
    /// <summary>
    /// This function returns the actual list of acceptable projections
    /// </summary>
    /// <param name=""></param>
    /// <returns>he list of the accetable projections</returns>
    List<options>^ getCurrentProjectionList(void) { return projection_list; }

    /// <summary>
    /// This function returns the projection name corresponding to the projection code
    /// </summary>
    /// <param name="code">The projection code</param>
    /// <returns>the projection name string</returns>
    static System::String^ getProjectionName(options code) { return tags[(int)code]; }

    /// <summary>
    /// This function returns the Image corresponding to the requested projection name string
    /// </summary>
    /// <param name="tag">is the name of the projection</param>
    /// <returns>The Image of the requested projection</returns>
    static Image^ getProjectionIcon(System::String^ tag) { return ProjectionsIcons[tag]; }

    /// <summary>
    /// This function returns the Image corresponding to the requested projection code
    /// </summary>
    /// <param name="code">is the code of the projection</param>
    /// <returns>The Image of the requested projection</returns>
    static Image^ getProjectionIcon(options code) { return ProjectionsIcons[tags[(int)code]]; }


private:
    options current_projection_code; //!< This is the code of the active selected projection
    System::String^ current_projection_name; //!< This is the name of the current selected projection
    static Dictionary<System::String^, Image^>^ ProjectionsIcons; //!< This is the Image list off all the possible projections;
    List<options>^ projection_list; //!< This is the list of the acceptable projections
};


/// <summary>
/// \ingroup ArmMotor_Module
/// 
/// This class implements the C-ARM activation features.
/// 
/// </summary>
/// 
/// The module inherits the base class CANOPEN::CanOpenMotor 
/// for the most of the motor control procedures.
/// 
/// In order to implement some specific function of the C-ARM,
/// the module overrides the following procedures:
/// + initializeSpecificObjectDictionaryCallback(): uploads some of the cmotor control register to adapt the motor performances to the C-ARM;
/// + completedCallback(): in order to implement the Virtual Isocentric compensation the module override this callback generated when the activation terminates; 
/// + faultCallback(): in case of fault the module generate an error message specific for the C-ARM.
/// 
/// See the \ref CARM for details about the features implemented by this module 
/// 
ref class ArmMotor : public CANOPEN::CanOpenMotor
{
public:
    

public:

    /// <summary>
    /// This is the ArmMotor class constructor
    /// 
    /// </summary>
	ArmMotor(void);

    /// <summary>
    /// This is the static reference to the C-ARM module.
    /// 
    /// The first use of the static reference in the Application 
    /// will causes an automatic auto instancing of the module
    /// 
    /// The application can have access to the non static members of this module 
    /// (for example the methods inherited by the base  class)  by using the ArmMotor::device-> reference.
    /// 
    /// 
    /// </summary>
    static ArmMotor^ device = gcnew ArmMotor();
    
    /// <summary>
    /// This function return true in case the current c-arm position is in the selected target angle.
    /// </summary>
    /// 
    /// The target angle is set by the application when requests for an automatic positioning.
    /// 
    /// The position is then considered in target if the actual motor position is into a +/- 0.01 degrees
    /// respect the selected target angle.
    /// 
    /// <param name=""></param>
    /// <returns>
    /// + true: the motor position is equal to the target position;
    /// + false: the motor position exceed the range of +/- 0.01 degrees from the target position;
    /// </returns>
    static bool isTarget(void) { return ((device->getCurrentUposition() >= selected_target - 1) && (device->getCurrentUposition() <= selected_target + 1)); }

    /// <summary>
    /// This function returns true in the case the current target position is flagged as valid target
    /// for exposure.
    /// 
    /// </summary>
    /// 
    /// \important
    /// The concept of valid target is intended as "Valid for the next exposure".
    /// 
    /// The module implements a specific and only method that sets a valid target: 
    /// + setTarget();
    /// 
    /// The Application should use this method only when the related target position needs to be guarantee;
    /// 
    /// Any other method that activates the motor invalidate the target position.
    /// 
    /// <param name=""></param>
    /// <returns>
    /// + true: the current target position is valid;
    /// + false: the current target is invalid for the next exposure.
    /// 
    /// \note
    /// A target  position can be set by other methods that cannot be used in operating mode (Open Study).
    /// In this case the target_position is flagged as non valid target.
    ///  
    /// </returns>
    static bool isValidTarget(void) { return valid_target; }

    /// <summary>
    /// This function checks if the current motor position belong to the acceptable angle range.
    ///  
    /// </summary>
    /// 
    /// \important
    /// The acceptable range is intended as the position range acceptable for the next exposure.
    /// 
    /// The module implements a specific and only method that sets the acceptable range: 
    /// + setTarget():  the Application should use this method only when the related target position needs to be guarantee;
    /// 
    /// The acceptable range is set by the Application to allow the motor to be in a different 
    /// position than the valid target position selected, so long as it belong to a limitad range,
    /// called acceptable range.
    /// 
    /// \note
    /// The manual activation of the motor with the manual buttons causes the motor position to change without changing 
    /// the current valid (or invalid) target position. 
    /// 
    ///
    /// <param name=""></param>
    /// <returns>
    /// + true: the current position belogs to the acceptable range;
    /// + false: the current position exceeds the acceptable range;
    /// </returns>
    static bool isInRange(void) { return ((device->getCurrentUposition() >= allowed_low) && (device->getCurrentUposition() <= allowed_high)); }
    
    /// <summary>
    /// This function checks if the current position is a valid position for the exposure.
    /// </summary>
    /// 
    /// This function actually tests both the valid target condition and valid range.
    /// 
    /// If the current target is a valid target and the current position, even if different from the target,
    /// is in the acceptable range, then the position can finally be considered as valid for the next exposure.
    /// 
    /// <param name=""></param>
    /// <returns>
    /// + true: the current motor position is valid for the exposure;
    /// + false: the current position is not valid for the next exposure;
    /// </returns>
    static bool isValidPosition(void) { return (valid_target && isInRange()); }

    /// <summary>
    /// This function activates the manual zero setting procedure.
    /// 
    /// </summary>   
    static bool startManualHoming(int target_position);

    /// <summary>
    /// This function activates the automatic zero setting procedure.
    /// 
    /// </summary>    
    static bool startAutoHoming();
    
    /// <summary>
    /// This is the method that activate the motor to a valid target angle and trigger the Isocentric Vertical correction.
    /// 
    /// </summary>    
    static int setTarget(int pos, int low, int high, System::String^ proj, int id);

    /// <summary>
    /// This function invalidate a current selected target.
    /// </summary>
    static void abortTarget(void);

    /// <summary>
    /// This is the service automatic activation that is not valid for an exposure.
    /// </summary>
    static bool serviceAutoPosition(int pos);

    /// <summary>
    /// This is the method to be called by the Application to activate the c-ARM chained Idle command.
    /// </summary>
    static bool setIdlePosition(void);

public:

    /// <summary>
    /// This method returns the current valid list of acceptable projections;
    /// </summary>
    /// <returns></returns>
    static inline ProjectionOptions^ getProjectionsList() { return projections; }

    /// <summary>
    /// This function returns the current selected projection name string
    /// </summary>
    /// <param name=""></param>
    /// <returns></returns>
    static System::String^ getSelectedProjection(void) { return projections->getCurrentProjectionName(); }

    /// <summary>
    /// This function returns the current selected projection code
    /// </summary>
    /// <param name=""></param>
    /// <returns></returns>
    static ProjectionOptions::options getSelectedProjectionCode(void) { return projections->getCurrentProjectionCode(); }

    /// <summary>
    /// This is the callback type function for the abort projection emission event
    /// </summary>
    delegate void delegate_abort_projection_request_callback(void);

    /// <summary>
    /// This is the event emitted by the module in case of an abort projection request is received.
    /// </summary>
    static event delegate_abort_projection_request_callback^ abort_projection_request_event;

    /// <summary>
    /// This is the method to request an abort projection event emission.
    /// </summary>
    /// <param name=""></param>
    static void abortProjectionRequest(void) { if (valid_target) abort_projection_request_event(); };

    /// <summary>
    /// This is the callback type function for the  projection selection request emission event
    /// </summary>
    delegate void delegate_projection_request_callback(System::String^ str);

    /// <summary>
    /// This is the event emitted by the module in case of a projection selection request is received.
    /// </summary>
    static event delegate_projection_request_callback^ projection_request_event;

    /// <summary>
    /// This is the method to request aprojection selection event emission.
    /// </summary>
    /// <param name=""></param>
    static void projectionRequest(System::String^ projection) {
        if (projections->isValidProjection(projection)) projection_request_event(projection); 
    }

protected:

    bool iso_activation_mode; //!< Setting this flag, causes the Vertical motor activation at the Arm rotation completion
    
    /// <summary>
    /// The module overrides this callback in order to update the module status at the command completion.
    /// </summary>
    void completedCallback(int id, MotorCommands current_command, int current_position, MotorCompletedCodes term_code) override; 
    
    /// <summary>
    /// The ArmMotor overrides this function in order to initialize specific motor registers during the startup fase.
    /// </summary>
    unsigned short initializeSpecificObjectDictionaryCallback(void) override; //!< Sets specific registers for the Arm activation    
    
    /// <summary>
    /// The module overrrides this callback in order to activate a specific error message
    /// </summary>
    void faultCallback(bool errstat, bool data_changed, unsigned int error_class, unsigned int error_code) override;
   

private:
    static ProjectionOptions^ projections = gcnew ProjectionOptions;  //!< This is the current selected projection
    static int         allowed_low = 0;            //!< Lower acceptable angle (°)
    static int         allowed_high = 0;           //!< Higher acceptable angle (°)
    static bool        valid_target = false;       //!< True if the target is a valid target
    static int         selected_target;            //!< Automatic selected target  
   
    
};
