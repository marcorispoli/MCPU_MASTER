.TH "CANOPEN::CanOpenMotor" 3 "Mon May 13 2024" "MCPU_MASTER Software Description" \" -*- nroff -*-
.ad l
.nh
.SH NAME
CANOPEN::CanOpenMotor
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <CanOpenMotor\&.h>\fP
.PP
Inherited by \fBArmMotor\fP, \fBBodyMotor\fP, \fBSlideMotor\fP, \fBTiltMotor\fP, and \fBVerticalMotor\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum class \fBstatus_options\fP { \fBstatus_options::MOTOR_NOT_CONNECTED\fP = 0, \fBstatus_options::MOTOR_CONFIGURATION\fP, \fBstatus_options::MOTOR_READY\fP, \fBstatus_options::MOTOR_BUSY\fP, \fBstatus_options::MOTOR_FAULT\fP }"
.br
.RI "This enumeration class descibes the internal status condition  "
.ti -1c
.RI "enum class \fBMotorCommands\fP { \fBMotorCommands::MOTOR_IDLE\fP = 0, \fBMotorCommands::MOTOR_AUTO_HOMING\fP, \fBMotorCommands::MOTOR_MANUAL_HOMING\fP, \fBMotorCommands::MOTOR_EXTERNAL_HOMING\fP, \fBMotorCommands::MOTOR_AUTO_POSITIONING\fP, \fBMotorCommands::MOTOR_MANUAL_POSITIONING\fP, \fBMotorCommands::MOTOR_MANUAL_SERVICE\fP }"
.br
.RI "This enumeration class descibes the Command codes "
.ti -1c
.RI "enum class \fBmotor_rotation_activations\fP { \fBmotor_rotation_activations::MOTOR_NO_ACTIVATION\fP, \fBmotor_rotation_activations::MOTOR_INCREASE\fP, \fBmotor_rotation_activations::MOTOR_DECREASE\fP, \fBmotor_rotation_activations::MOTOR_UNDEFINED\fP }"
.br
.ti -1c
.RI "enum class \fBMotorCompletedCodes\fP { \fBMotorCompletedCodes::COMMAND_SUCCESS\fP = 0, \fBMotorCompletedCodes::COMMAND_PROCEED\fP = 0, \fBMotorCompletedCodes::COMMAND_MANUAL_TERMINATION\fP, \fBMotorCompletedCodes::MOTOR_ERRORS\fP, \fBMotorCompletedCodes::ERROR_OBSTACLE_DETECTED\fP = MOTOR_ERRORS, \fBMotorCompletedCodes::ERROR_MOTOR_BUSY\fP, \fBMotorCompletedCodes::ERROR_INITIALIZATION\fP, \fBMotorCompletedCodes::ERROR_UNEXPECTED_STATUS\fP, \fBMotorCompletedCodes::ERROR_LIMIT_SWITCH\fP, \fBMotorCompletedCodes::ERROR_BRAKE_DEVICE\fP, \fBMotorCompletedCodes::ERROR_TIMOUT\fP, \fBMotorCompletedCodes::ERROR_INTERNAL_FAULT\fP, \fBMotorCompletedCodes::ERROR_ACCESS_REGISTER\fP, \fBMotorCompletedCodes::ERROR_MISSING_HOME\fP, \fBMotorCompletedCodes::ERROR_TARGET_OUT_OF_RANGE\fP, \fBMotorCompletedCodes::ERROR_COMMAND_DISABLED\fP, \fBMotorCompletedCodes::ERROR_COMMAND_ABORTED\fP, \fBMotorCompletedCodes::ERROR_COMMAND_DEMO\fP, \fBMotorCompletedCodes::ERROR_SAFETY\fP, \fBMotorCompletedCodes::ERROR_STARTING_NANOJ\fP, \fBMotorCompletedCodes::ERROR_INVALID_COMMAND\fP }"
.br
.RI "This enumeration class descibes the command complete codes  "
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBCanOpenMotor\fP (unsigned char devid, LPCWSTR motorname, System::String^ parameter, Notify::messages home_err, int \fBmin_position\fP, int \fBmax_position\fP, double gear, double external_k, bool reverse)"
.br
.RI "This is the base class constructor\&. "
.ti -1c
.RI "void \fBrunMode\fP (void)"
.br
.ti -1c
.RI "void \fBdemoMode\fP (void)"
.br
.ti -1c
.RI "delegate void \fBdelegate_fault_callback\fP (int code)"
.br
.RI "Delegate for the callback related to the Fault condition\&. "
.ti -1c
.RI "delegate void \fBdelegate_command_completed_callback\fP (int id, int code)"
.br
.RI "Delegate for the command completed event 
.br
 "
.ti -1c
.RI "bool \fBactivateRelativePositioning\fP (int id, int target, int speed, int acc, int dec)"
.br
.RI "This function starts an automatic relative positioning 
.br
 "
.ti -1c
.RI "bool \fBactivateRelativePositioning\fP (int id, int target)"
.br
.RI "This function starts an automatic relative positioning with predefined motor parameters\&. "
.ti -1c
.RI "bool \fBactivateAutomaticPositioning\fP (int id, int target, int speed, int acc, int dec, bool autostart)"
.br
.RI "This function starts an automatic positioning 
.br
 "
.ti -1c
.RI "bool \fBactivateAutomaticPositioning\fP (int id, int target, bool autostart)"
.br
.RI "This function starts an automatic positioning with predefined parameters 
.br
 "
.ti -1c
.RI "bool \fBactivateAutomaticHoming\fP (int method_on, int method_off, int speed, int acc)"
.br
.RI "This function starts the automatic homing procedure\&. "
.ti -1c
.RI "bool \fBactivateExternalHoming\fP (int current_uposition)"
.br
.RI "This function starts the external sensor homing procedure\&. "
.ti -1c
.RI "bool \fBactivateManualHoming\fP (int current_uposition)"
.br
.RI "This function starts the external sensor homing procedure\&. "
.ti -1c
.RI "bool \fBactivateManualPositioning\fP (int target, int speed, int acc, int dec)"
.br
.RI "This command activates the manual mootion 
.br
 "
.ti -1c
.RI "bool \fBactivateManualPositioning\fP (int target)"
.br
.RI "This command activates the manual mootion with predefined parameters\&. "
.ti -1c
.RI "bool \fBactivateManualService\fP (bool increase)"
.br
.ti -1c
.RI "void \fBsetServiceMode\fP (bool stat)"
.br
.ti -1c
.RI "void \fBabortActivation\fP (void)"
.br
.RI "Immediate abort of any activation running\&. "
.ti -1c
.RI "\fBstatus_options\fP \fBgetInternalStatus\fP (void)"
.br
.RI "This function returns the internal module status\&. "
.ti -1c
.RI "System::String ^ \fBgetInternalStatusStr\fP (void)"
.br
.RI "This function returns a description string of the internal motor status  "
.ti -1c
.RI "\fBMotorCompletedCodes\fP \fBgetCommandCompletedCode\fP (void)"
.br
.RI "This function returns the last command termination code  "
.ti -1c
.RI "bool \fBactivateConfiguration\fP (void)"
.br
.RI "This function activates the Driver configuration fase  "
.ti -1c
.RI "bool \fBisPositionFromExternalSensor\fP (void)"
.br
.ti -1c
.RI "bool \fBisConfigurating\fP (void)"
.br
.RI "This function returns the current configuration fase status  "
.ti -1c
.RI "bool \fBisODConfigured\fP (void)"
.br
.RI "This function returns the status of the Object Dictionary configuration status  "
.ti -1c
.RI "bool \fBisNanojConfigured\fP (void)"
.br
.RI "This function returns the status of the Nano-J programming  "
.ti -1c
.RI "bool \fBisReady\fP (void)"
.br
.RI "This function returns true if the module is ready to execute a command\&.  "
.ti -1c
.RI "bool \fBisBusy\fP (void)"
.br
.RI "This function return true if an executing command is pending  "
.ti -1c
.RI "bool \fBisRunning\fP (void)"
.br
.RI "This function return true if a command is executing\&. "
.ti -1c
.RI "bool \fBisZeroOk\fP (void)"
.br
.RI "This function returns the Encoder Zero setting status  "
.ti -1c
.RI "int \fBgetCurrentPosition\fP (void)"
.br
.RI "This function returns the current encoder position\&.  "
.ti -1c
.RI "unsigned short \fBgetExternalSensor\fP (void)"
.br
.ti -1c
.RI "int \fBgetExternalPosition\fP (void)"
.br
.ti -1c
.RI "int \fBgetEncoderPosition\fP (void)"
.br
.ti -1c
.RI "int \fBgetMinPosition\fP (void)"
.br
.ti -1c
.RI "int \fBgetMaxPosition\fP (void)"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "int \fBgetPreviousPosition\fP (void)"
.br
.RI "This function returns the previous position before the last activation execution\&. "
.ti -1c
.RI "void \fBsetNanoJPtr\fP (const unsigned char *ptr, int size)"
.br
.RI "This function assignes the binary pointer of the nano-j program to be uploaded during the configuration fase\&.  "
.ti -1c
.RI "int \fBgetCurrentEncoderEposition\fP (void)"
.br
.RI "This function returns the current encoder position in Encoder internal units  "
.ti -1c
.RI "int \fBgetCurrentEncoderUposition\fP (void)"
.br
.ti -1c
.RI "int \fBgetCurrentUposition\fP (void)"
.br
.RI "This function returns the current user defined position  "
.ti -1c
.RI "void \fBsetTargetRange\fP (int h, int l)"
.br
.RI "This function set the current acceptable position range\&.  "
.ti -1c
.RI "bool \fBisEncoderInitialized\fP (void)"
.br
.RI "This function returns the current encoder zero setting status "
.ti -1c
.RI "void \fBsetEncoderInitStatus\fP (bool val)"
.br
.RI "This function allows the subclass to set the current zero setting status  "
.ti -1c
.RI "int \fBconvert_Encoder_To_User\fP (int x)"
.br
.RI "This function translate internal encoder position to the unit position value  "
.ti -1c
.RI "int \fBconvert_User_To_Encoder\fP (int x)"
.br
.RI "This function translate the user position to the encoder position  "
.ti -1c
.RI "int \fBconvert_UserSec_To_Speed\fP (int x)"
.br
.RI "This function is used to transform the user defined speed or acceleration into the SPeed or Acceleration internal encoder units "
.ti -1c
.RI "bool \fBblocking_writeOD\fP (unsigned short index, unsigned char sub, \fBODRegister::SDODataDimension\fP dim, int val)"
.br
.RI "This function writes a SDO register in the target motor device; "
.ti -1c
.RI "void \fBwrite_resetNode\fP (void)"
.br
.RI "This function sends a Reset Node command to the device\&. "
.ti -1c
.RI "bool \fBblocking_readOD\fP (unsigned short index, unsigned char sub, \fBODRegister::SDODataDimension\fP dim)"
.br
.RI "This function Reads a SDO register in the target motor device; "
.ti -1c
.RI "bool \fBwriteControlWord\fP (unsigned int mask, unsigned int val)"
.br
.RI "This function writes a part of the control word\&. "
.ti -1c
.RI "bool \fBreadControlWord\fP (unsigned int *ctrlw)"
.br
.RI "This function reads the control word\&. "
.ti -1c
.RI "bool \fBstartRotation\fP (void)"
.br
.RI "This function starts the motor rotation\&.  "
.ti -1c
.RI "bool \fBstartNanoj\fP (void)"
.br
.RI "This function runs the Nano-J program on the Motor Device  "
.ti -1c
.RI "bool \fBstopNanoj\fP (void)"
.br
.RI "This function stops a running Nano-J program\&. "
.ti -1c
.RI "virtual void \fBmotionParameterCallback\fP (\fBMotorCommands\fP \fBcurrent_command\fP, int current_position, int target_position)"
.br
.ti -1c
.RI "virtual \fBMotorCompletedCodes\fP \fBpreparationCallback\fP (\fBMotorCommands\fP \fBcurrent_command\fP, int current_position, int target_position)"
.br
.RI "This function is called just before to set the speed: if return true, the speed is set to the predefined value\&. "
.ti -1c
.RI "virtual \fBMotorCompletedCodes\fP \fBrunningCallback\fP (\fBMotorCommands\fP \fBcurrent_command\fP, int current_position, int target_position)"
.br
.RI "This function is called just before to Power the motor phases\&. "
.ti -1c
.RI "virtual void \fBcompletedCallback\fP (int id, \fBMotorCommands\fP \fBcurrent_command\fP, int current_position, \fBMotorCompletedCodes\fP term_code)"
.br
.RI "This function is called just before to Power the motor phases\&. "
.ti -1c
.RI "virtual \fBMotorCompletedCodes\fP \fBidleCallback\fP (void)"
.br
.RI "This function is called just before to Power the motor phases\&. "
.ti -1c
.RI "virtual void \fBfaultCallback\fP (bool errstat, bool data_change, unsigned int \fBerror_class\fP, unsigned int \fBerror_code\fP)"
.br
.ti -1c
.RI "virtual void \fBresetCallback\fP (void)"
.br
.RI "Called whenever the boot message is received from the device\&. "
.ti -1c
.RI "virtual unsigned short \fBinitializeSpecificObjectDictionaryCallback\fP (void)"
.br
.RI "Override this function to initialize specific registers of the target Motor Device\&. "
.ti -1c
.RI "virtual bool \fBunbrakeCallback\fP (void)"
.br
.RI "Called whenever the optional brake device should be released\&. "
.ti -1c
.RI "virtual bool \fBbrakeCallback\fP (void)"
.br
.RI "Called whenever the optional brake device should be reactivated\&. "
.ti -1c
.RI "virtual void \fBdemoLoop\fP (void)"
.br
.ti -1c
.RI "void \fBsetCommandCompleted\fP (\fBMotorCompletedCodes\fP error)"
.br
.ti -1c
.RI "int \fBgetCommandId\fP (void)"
.br
.RI "This function returns the current command-id\&.  "
.ti -1c
.RI "\fBODRegister\fP ^ \fBgetRxReg\fP (void)"
.br
.RI "Returns the pointer of the reception sdo register  "
.ti -1c
.RI "void \fBsetSpeed\fP (int val)"
.br
.RI "Modifies the assigned command speed (to be used into the \fBmotionParameterCallback()\fP) "
.ti -1c
.RI "void \fBsetAcc\fP (int val)"
.br
.RI "Modifies the assigned command acceleration (to be used into the \fBmotionParameterCallback()\fP) "
.ti -1c
.RI "void \fBsetDec\fP (int val)"
.br
.RI "Modifies the assigned command deceleration (to be used into the \fBmotionParameterCallback()\fP) "
.ti -1c
.RI "\fBmotor_rotation_activations\fP \fBgetMotorDirection\fP (void)"
.br
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "static System::String ^ \fBgetErrorClass1001\fP (unsigned int val)"
.br
.RI "This is a convenient function to decode a Error string from the error of the register 1001\&. "
.ti -1c
.RI "static System::String ^ \fBgetErrorClass1003\fP (unsigned int val)"
.br
.RI "This is a convenient function to decode a Error Class string from the register 1003\&. "
.ti -1c
.RI "static System::String ^ \fBgetErrorCode1003\fP (unsigned int val)"
.br
.RI "This is a convenient function to decode a Error Code string from the register 1003\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "bool \fBsimulator_mode\fP"
.br
.ti -1c
.RI "unsigned char \fBdevice_id\fP"
.br
.RI "This is the target Device Id\&. "
.ti -1c
.RI "System::String ^ \fBconfig_param\fP"
.br
.RI "Pointer to the parameter in the config parameter 
.br
 "
.ti -1c
.RI "Notify::messages \fBerror_homing\fP"
.br
.ti -1c
.RI "bool \fBfault_activation\fP"
.br
.in -1c
.SS "Events"

.in +1c
.ti -1c
.RI "\fBdelegate_fault_callback\fP^ \fBfault_event\fP"
.br
.RI "Event generated when a Driver fault condition is detected\&. "
.ti -1c
.RI "\fBdelegate_command_completed_callback\fP^ \fBcommand_completed_event\fP"
.br
.RI "Event generated at the command completion\&. "
.in -1c
.SS "Private Types"

.in +1c
.ti -1c
.RI "enum class \fB_CiA402Status\fP { \fBCiA402_NotReadyToSwitchOn\fP = 0, \fBCiA402_SwitchOnDisabled\fP, \fBCiA402_ReadyToSwitchOn\fP, \fBCiA402_SwitchedOn\fP, \fBCiA402_OperationEnabled\fP, \fBCiA402_QuickStopActive\fP, \fBCiA402_FaultReactionActive\fP, \fBCiA402_Fault\fP, \fBCiA402_Undefined\fP }"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "bool \fBupdate_external_position\fP (void)"
.br
.RI "read the external sensor and fill the external data "
.ti -1c
.RI "void \fBthread_canopen_rx_sdo_callback\fP (unsigned short canid, unsigned char *data, unsigned char len)"
.br
.RI "This is the CAN sdo reception callback\&. "
.ti -1c
.RI "void \fBthread_canopen_bootup_callback\fP (unsigned short canid, unsigned char *data, unsigned char len)"
.br
.RI "This is the CAN boot reception callback\&. "
.ti -1c
.RI "void \fBmainWorker\fP (void)"
.br
.RI "This is the Main thread managing the communication with the motor\&. "
.ti -1c
.RI "\fB_CiA402Status\fP \fBgetCiAStatus\fP (int regval)"
.br
.RI "This function is internally used to decode the content of the Status register and returning the current CiA status code\&. "
.ti -1c
.RI "System::String ^ \fBgetCiAStatusString\fP (\fB_CiA402Status\fP status)"
.br
.RI "This convenient function return a String name of the curent CiA status  "
.ti -1c
.RI "void \fBCiA402_QuickStopActiveCallback\fP (void)"
.br
.RI "This function is called when the CiA402_QuickStopActive status is detected\&. "
.ti -1c
.RI "void \fBCiA402_SwitchOnDisabledCallback\fP (void)"
.br
.RI "This function handles the SwitchOnDisabled CiA status\&. "
.ti -1c
.RI "void \fBCiA402_ReadyToSwitchOnCallback\fP (void)"
.br
.RI "This function is called when the CiA402_ReadyToSwitchOn status is detected\&. "
.ti -1c
.RI "void \fBCiA402_SwitchedOnCallback\fP (void)"
.br
.RI "This function is called when the CiA402_SwitchedOn status is detected\&. 
.br
 "
.ti -1c
.RI "void \fBCiA402_OperationEnabledCallback\fP (void)"
.br
.RI "This function is called when the CiA402_OperationEnabled status is detected\&. "
.ti -1c
.RI "void \fBCiA402_FaultCallback\fP (void)"
.br
.RI "This function handles the CiA_Fault status "
.ti -1c
.RI "bool \fBsetEncoderCommand\fP (int eposition)"
.br
.RI "This function reset the Encoder internal position to a predefined value\&.  "
.ti -1c
.RI "bool \fBinitializeObjectDictionary\fP (void)"
.br
.ti -1c
.RI "bool \fBinitNanojDataRegister\fP (void)"
.br
.RI "This function initializes the Nanoj program download "
.ti -1c
.RI "bool \fBnanojWrite1024Block\fP (int index, int size)"
.br
.RI "This function Upload a block of 1024 byte into the Motor nanoj Ram Area "
.ti -1c
.RI "bool \fBuploadNanojProgram\fP (void)"
.br
.RI "This function handles the Upload nanoj program steps\&. "
.ti -1c
.RI "void \fBsetCommandCompletedCode\fP (\fBMotorCompletedCodes\fP error)"
.br
.RI "This function 
.br
 "
.ti -1c
.RI "void \fBupdateCurrentPosition\fP (void)"
.br
.RI "This function updates the current position\&. "
.ti -1c
.RI "int \fBgetActivationTimeout\fP (int speed, int acc, int dec, int target)"
.br
.RI "This function returns the activation timeout extimation, based on the speed and target parameters\&. "
.ti -1c
.RI "bool \fBisTarget\fP (void)"
.br
.ti -1c
.RI "void \fBmanageAutomaticPositioning\fP (void)"
.br
.RI "This function executes the Automatic positioning of the motor at the expected target position\&. "
.ti -1c
.RI "void \fBmanageManualPositioning\fP (void)"
.br
.ti -1c
.RI "void \fBmanageManualServicePositioning\fP (void)"
.br
.ti -1c
.RI "void \fBmanageAutomaticHoming\fP (void)"
.br
.ti -1c
.RI "void \fBmanageManualHoming\fP (int zero_position)"
.br
.ti -1c
.RI "void \fBmanageExternalHoming\fP (int zero_position)"
.br
.RI "This function gets the external zero position sensor 
.br
 "
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "bool \fBrun\fP"
.br
.ti -1c
.RI "bool \fBreset_node\fP"
.br
.ti -1c
.RI "int \fBmax_position\fP"
.br
.RI "This is the maximum target selectable\&. "
.ti -1c
.RI "int \fBmin_position\fP"
.br
.RI "This is the minimum target selectable\&. "
.ti -1c
.RI "bool \fBservice_mode\fP"
.br
.ti -1c
.RI "HANDLE \fBrxSDOEvent\fP"
.br
.RI "Event object signaled by the SDO receiving callback\&. "
.ti -1c
.RI "bool \fBsdo_rx_pending\fP"
.br
.RI "A SDO reception fdata is pending\&. "
.ti -1c
.RI "bool \fBnanoj_rx_pending\fP"
.br
.RI "A SDO reception fdata is pending\&. "
.ti -1c
.RI "\fBODRegister\fP ^ \fBrxSdoRegister\fP"
.br
.RI "SDO receiving data\&. "
.ti -1c
.RI "unsigned char \fBrxNanojAck\fP"
.br
.RI "Nanoj ack byte\&. "
.ti -1c
.RI "bool \fBrxNanojAckValid\fP"
.br
.RI "Nano-j Ack vaild\&. "
.ti -1c
.RI "\fBstatus_options\fP \fBinternal_status\fP"
.br
.RI "This is the current internal motor status\&. "
.ti -1c
.RI "bool \fBhome_initialized\fP"
.br
.RI "The device has executed the homing procedure 
.br
 "
.ti -1c
.RI "bool \fBexternal_position_mode\fP"
.br
.ti -1c
.RI "unsigned short \fBexternal_raw_position\fP"
.br
.RI "The current position is detected with the analog input from an external source (potentiometer) "
.ti -1c
.RI "unsigned short \fBexternal_zero_setting\fP"
.br
.RI "Potentiometer value at mechanical zero position\&. "
.ti -1c
.RI "int \fBexternal_uposition\fP"
.br
.RI "Current user position calculate from the external source\&. "
.ti -1c
.RI "float \fBexternal_k_coeff\fP"
.br
.RI "user_position/external_raw_position coefficient "
.ti -1c
.RI "int \fBencoder_eposition\fP"
.br
.RI "Current Encoder position\&. "
.ti -1c
.RI "int \fBencoder_uposition\fP"
.br
.RI "Current User position\&. "
.ti -1c
.RI "bool \fBreverse_direction\fP"
.br
.RI "Changes the polarity of the position\&. "
.ti -1c
.RI "int \fBprevious_uposition\fP"
.br
.RI "This is the last target position for non coordinate activations\&. "
.ti -1c
.RI "int \fBtarget_range_h\fP"
.br
.RI "This is the acceptable target range in user units (upper limit) "
.ti -1c
.RI "int \fBtarget_range_l\fP"
.br
.RI "This is the acceptable target range in user units (lower limit) "
.ti -1c
.RI "bool \fBod_initialized\fP"
.br
.RI "Object dictionary has been intialized\&. "
.ti -1c
.RI "bool \fBnanoj_initialized\fP"
.br
.RI "Nano-J program has been intialized\&. "
.ti -1c
.RI "double \fBrot_per_unit\fP"
.br
.RI "This is the assigned Rotation/units convertion factor\&. "
.ti -1c
.RI "Thread ^ \fBmain_thread\fP"
.br
.ti -1c
.RI "\fB_CiA402Status\fP \fBCiA_current_status\fP"
.br
.RI "CiA current detected status\&. "
.ti -1c
.RI "bool \fBerror_condition\fP"
.br
.ti -1c
.RI "unsigned int \fBerror_class\fP"
.br
.ti -1c
.RI "unsigned int \fBerror_code\fP"
.br
.ti -1c
.RI "bool \fBconfiguration_command\fP"
.br
.ti -1c
.RI "const unsigned char * \fBpNanoj\fP"
.br
.ti -1c
.RI "int \fBnanojSize\fP"
.br
.ti -1c
.RI "\fBMotorCommands\fP \fBrequest_command\fP"
.br
.RI "Application request command code\&. "
.ti -1c
.RI "bool \fBabort_request\fP"
.br
.RI "This flag active causes an immediate command abort\&. "
.ti -1c
.RI "\fBMotorCommands\fP \fBcurrent_command\fP"
.br
.RI "Current executing command code\&. "
.ti -1c
.RI "\fBMotorCompletedCodes\fP \fBcommand_completed_code\fP"
.br
.RI "Activation result\&. "
.ti -1c
.RI "int \fBcommand_id\fP"
.br
.RI "ID code of the requested command\&. "
.ti -1c
.RI "int \fBcommand_target\fP"
.br
.RI "Target position in user units\&. "
.ti -1c
.RI "int \fBcommand_acc\fP"
.br
.RI "Acceleration in user/s2\&. "
.ti -1c
.RI "int \fBcommand_dec\fP"
.br
.RI "Deceleration in user/s2\&. "
.ti -1c
.RI "int \fBcommand_speed\fP"
.br
.RI "Speed in user/s\&. "
.ti -1c
.RI "int \fBcommand_ms_tmo\fP"
.br
.RI "Timeout activation in ms\&. "
.ti -1c
.RI "bool \fBcommand_stop\fP"
.br
.RI "Request to stop the current activation\&. "
.ti -1c
.RI "int \fBcommand_homing_on_method\fP"
.br
.RI "Homing method whith zero photocell starting in ON status\&. "
.ti -1c
.RI "int \fBcommand_homing_off_method\fP"
.br
.RI "Homing method whith zero photocell starting in OFF status\&. "
.ti -1c
.RI "bool \fBautostart_mode\fP"
.br
.RI "Set to tru if the activation ommand is automatically started\&. "
.ti -1c
.RI "\fBmotor_rotation_activations\fP \fBmotor_direction\fP"
.br
.RI "The current direction of the motor activation\&. "
.ti -1c
.RI "double \fBtxrx_time\fP"
.br
.ti -1c
.RI "bool \fBread_sdo_tmo\fP"
.br
.ti -1c
.RI "bool \fBwrite_sdo_tmo\fP"
.br
.ti -1c
.RI "unsigned long \fBsent_messages\fP"
.br
.ti -1c
.RI "unsigned long \fBsent_5\fP"
.br
.ti -1c
.RI "unsigned long \fBsent_10\fP"
.br
.ti -1c
.RI "unsigned long \fBsent_15\fP"
.br
.ti -1c
.RI "unsigned long \fBsent_20\fP"
.br
.ti -1c
.RI "unsigned long \fBsent_25\fP"
.br
.ti -1c
.RI "unsigned long \fBsent_30\fP"
.br
.ti -1c
.RI "unsigned long \fBsent_xx\fP"
.br
.ti -1c
.RI "double \fBperc5\fP"
.br
.ti -1c
.RI "double \fBperc10\fP"
.br
.ti -1c
.RI "double \fBperc15\fP"
.br
.ti -1c
.RI "double \fBperc20\fP"
.br
.ti -1c
.RI "double \fBperc25\fP"
.br
.ti -1c
.RI "double \fBperc30\fP"
.br
.ti -1c
.RI "double \fBpercXX\fP"
.br
.ti -1c
.RI "double \fBmeanTime\fP"
.br
.ti -1c
.RI "double \fBpercMeanTime\fP"
.br
.ti -1c
.RI "unsigned long \fBunreceived_messages\fP"
.br
.in -1c
.SS "Static Private Attributes"

.in +1c
.ti -1c
.RI "static const cli::array< System::String^> ^ \fBstatus_tags\fP = gcnew cli::array<System::String^> { 'NOT CONNECTED', 'CONFIGURATION', 'READY', 'BUSY', 'FAULT'}"
.br
.in -1c
.SH "Member Enumeration Documentation"
.PP 
.SS "enum class \fBCANOPEN::CanOpenMotor::_CiA402Status\fP\fC [strong]\fP, \fC [private]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fICiA402_NotReadyToSwitchOn \fP\fP
.TP
\fB\fICiA402_SwitchOnDisabled \fP\fP
.TP
\fB\fICiA402_ReadyToSwitchOn \fP\fP
.TP
\fB\fICiA402_SwitchedOn \fP\fP
.TP
\fB\fICiA402_OperationEnabled \fP\fP
.TP
\fB\fICiA402_QuickStopActive \fP\fP
.TP
\fB\fICiA402_FaultReactionActive \fP\fP
.TP
\fB\fICiA402_Fault \fP\fP
.TP
\fB\fICiA402_Undefined \fP\fP
.SH "Member Function Documentation"
.PP 
.SS "void CanOpenMotor::CiA402_FaultCallback (void)\fC [private]\fP"

.PP
This function handles the CiA_Fault status The motor device enters a fault status whenever an intrnal fault condition is detected\&.
.PP
This module read the error code from the device and, as soon as the error condition expires, try to exit from the CiA_Fault status to the CiA_SwitchedOn status (operating status)\&.
.PP
When a new error is generated or when the error condition expires, the module generate the event: \fBfault_event(error_code)\fP
.SS "void CanOpenMotor::CiA402_OperationEnabledCallback (void)\fC [private]\fP"

.PP
This function is called when the CiA402_OperationEnabled status is detected\&. The Application cannot remains in this status out of a command execution because the motor wires are powered and a torque is applied\&.
.PP
The module tries to enter the CiA402_SwitchedOn from this status
.SS "void CanOpenMotor::CiA402_QuickStopActiveCallback (void)\fC [private]\fP"

.PP
This function is called when the CiA402_QuickStopActive status is detected\&. The module tries to enter the ReadyToSwitchOn from this status  
.SS "void CanOpenMotor::CiA402_ReadyToSwitchOnCallback (void)\fC [private]\fP"

.PP
This function is called when the CiA402_ReadyToSwitchOn status is detected\&. The module tries to enter the CiA402_SwitchedOn from this status  
.SS "void CanOpenMotor::CiA402_SwitchedOnCallback (void)\fC [private]\fP"

.PP
This function is called when the CiA402_SwitchedOn status is detected\&. 
.br
 This is the Operating status machine\&. The activation commands can be performed in this status\&.  
.SS "void CanOpenMotor::CiA402_SwitchOnDisabledCallback (void)\fC [private]\fP"

.PP
This function handles the SwitchOnDisabled CiA status\&. The module tries to enter the ReadyToSwitchOn from this status  
.SS "int CanOpenMotor::getActivationTimeout (int speed, int acc, int dec, int target)\fC [private]\fP"

.PP
This function returns the activation timeout extimation, based on the speed and target parameters\&. The Activation algorithm control the speed with a trapezioidal mode:
.IP "\(bu" 2
A constant acceleration until a target speed is reached;
.IP "\(bu" 2
A constant speed until a deceleration point is reached;
.IP "\(bu" 2
A constant deceleration until a target is reached;
.PP
.PP
The timeout is calculated based on this operating mode
.PP
\fBParameters\fP
.RS 4
\fIspeed\fP The activation speed in User units
.br
\fIacc\fP The activation Acc in user units
.br
\fIdec\fP The activation Dec in user units
.br
\fItarget\fP The target position in user units
.RE
.PP

.SS "\fBCanOpenMotor::_CiA402Status\fP CanOpenMotor::getCiAStatus (int regval)\fC [private]\fP"

.PP
This function is internally used to decode the content of the Status register and returning the current CiA status code\&. 
.PP
\fBParameters\fP
.RS 4
\fIregval\fP The content of the Status register
.RE
.PP
\fBReturns\fP
.RS 4
The detected CiA status code
.RE
.PP

.SS "System::String CanOpenMotor::getCiAStatusString (\fB_CiA402Status\fP status)\fC [private]\fP"

.PP
This convenient function return a String name of the curent CiA status  
.PP
\fBParameters\fP
.RS 4
\fIstatus\fP the CiA status code
.RE
.PP
\fBReturns\fP
.RS 4
The String name of the CiA status code
.RE
.PP

.SS "\fBmotor_rotation_activations\fP CANOPEN::CanOpenMotor::getMotorDirection (void)\fC [inline]\fP, \fC [protected]\fP"

.SS "bool CanOpenMotor::initializeObjectDictionary (void)\fC [private]\fP"

.PP
This function initializes the principals motor driver registers\&. 
.PP
This function is called during the initialization fase in order to set the internal register with default values, widely used for PD4 motors\&.
.PP
The function will call the \fBinitializeSpecificObjectDictionaryCallback()\fP function:
.IP "\(bu" 2
The Subclass module should override this function to set specific registers\&.
.PP
.PP
\fBReturns\fP
.RS 4
true in case of success
.RE
.PP

.SS "bool CanOpenMotor::initNanojDataRegister (void)\fC [private]\fP"

.PP
This function initializes the Nanoj program download 
.PP
\fBReturns\fP
.RS 4

.RE
.PP

.SS "bool CANOPEN::CanOpenMotor::isTarget (void)\fC [inline]\fP, \fC [private]\fP"

.SS "void CanOpenMotor::mainWorker (void)\fC [private]\fP"

.PP
This is the Main thread managing the communication with the motor\&. The threads:
.IP "\(bu" 2
handles the CiA status machine;
.IP "\(bu" 2
handles the execution of the commands (only in SwitchedOn status)
.IP "\(bu" 2
handles the motor exceptions\&.
.IP "\(bu" 2
handles the motor configuration\&.
.PP
.PP
The thread leads the motor driver to enter the CiA-SwitchedOn status if possible\&.
.PP
When the driver reaches the CiA-SwitchedOn status, the motor activation commands can be performed\&.
.PP
If the Motor should enter a CiA-Fault status, the thread handles the fault condition 
.br
and as soon as the fault condition expires it tries to report the current status to the CiA-SwitchedOn status\&.
.SS "void CanOpenMotor::manageAutomaticHoming (void)\fC [private]\fP"

.SS "void CanOpenMotor::manageAutomaticPositioning (void)\fC [private]\fP"

.PP
This function executes the Automatic positioning of the motor at the expected target position\&. The procedure executes the following steps for preparation:
.IP "\(bu" 2
sets the expected timeout in ms;
.IP "\(bu" 2
verifies if the current position should be already in target (termines immediatelly);
.IP "\(bu" 2
upload the running parameters: speed, acceleration deceleration;
.IP "\(bu" 2
Activate the Power to the motor wires;
.IP "\(bu" 2
Calls the automaticPositioningPreparationCallback();
.IP "\(bu" 2
stores the encoder current_position (before to move) in the previous_position variable;
.PP
.PP
The procedure executes the following steps for the running management:
.PP
.IP "\(bu" 2
updates the current position;
.IP "\(bu" 2
checks for the Abort request (from the application);
.IP "\(bu" 2
verifies if the current CiA status should be changed: in this case termines with error;
.IP "\(bu" 2
verifies if the activation timeout should expires\&. In this case termines with error;
.IP "\(bu" 2
calls the automaticPositioningRunningCallback() for the subclass management;
.IP "\(bu" 2
verifies if the target is detected in three possible ways:
.IP "  \(bu" 4
The motor signals automatically the target (usually it should);
.IP "  \(bu" 4
The current position matches with the target position (less probable);
.IP "  \(bu" 4
in case of timeout if the position should be in the acceptable range (recovery strategy);
.PP

.PP
.PP
The procedure executes the following steps for the command termination:
.PP
.IP "\(bu" 2
updates the current position;
.IP "\(bu" 2
calls the automaticPositioningCompletedCallback() for the subclass management;
.IP "\(bu" 2
exits form the Powered mode to the Idle status (if not in CiA-Fault);
.PP

.SS "void CanOpenMotor::manageExternalHoming (int zero_position)\fC [private]\fP"

.PP
This function gets the external zero position sensor 
.br
 
.SS "void CanOpenMotor::manageManualHoming (int zero_position)\fC [private]\fP"

.SS "void CanOpenMotor::manageManualPositioning (void)\fC [private]\fP"

.SS "void CanOpenMotor::manageManualServicePositioning (void)\fC [private]\fP"

.SS "bool CanOpenMotor::nanojWrite1024Block (int vectorIndex, int block_size)\fC [private]\fP"

.PP
This function Upload a block of 1024 byte into the Motor nanoj Ram Area 
.PP
\fBParameters\fP
.RS 4
\fIvectorIndex\fP pointer to the nanoj program vector at the current position
.br
\fIblock_size\fP block size definition
.RE
.PP
\fBReturns\fP
.RS 4
.RE
.PP

.SS "void CANOPEN::CanOpenMotor::setAcc (int val)\fC [inline]\fP, \fC [protected]\fP"

.PP
Modifies the assigned command acceleration (to be used into the \fBmotionParameterCallback()\fP) 
.SS "void CanOpenMotor::setCommandCompletedCode (\fBMotorCompletedCodes\fP term_code)\fC [private]\fP"

.PP
This function 
.br
 This function is internally used to set a command completion code\&.
.PP
The function calls the command related callbacks:
.IP "\(bu" 2
automaticPositioningCompletedCallback: in case of Automatic positioning command termination
.IP "\(bu" 2
automaticHomingCompletedCallback: in case of a Homing command termination
.IP "\(bu" 2
manualPositioningCompletedCallback: in case of manual command termination
.PP
.PP
\fBParameters\fP
.RS 4
\fIterm_code\fP the termination code
.RE
.PP

.SS "void CANOPEN::CanOpenMotor::setDec (int val)\fC [inline]\fP, \fC [protected]\fP"

.PP
Modifies the assigned command deceleration (to be used into the \fBmotionParameterCallback()\fP) 
.SS "bool CanOpenMotor::setEncoderCommand (int initial_eposition)\fC [private]\fP"

.PP
This function reset the Encoder internal position to a predefined value\&.  
.IP "\(bu" 2
The function sets the variable 'home_initialized' to TRUE in case of success;
.IP "\(bu" 2
The function sets the variable 'home_initialized' to FALSE in case of failure;
.PP
.PP
NOTE: the function returns FALSE only if a communication error happen\&.
.PP
\fBReturns\fP
.RS 4
true: no communcation errors
.RE
.PP

.SS "void CANOPEN::CanOpenMotor::setSpeed (int val)\fC [inline]\fP, \fC [protected]\fP"

.PP
Modifies the assigned command speed (to be used into the \fBmotionParameterCallback()\fP) 
.SS "void CanOpenMotor::thread_canopen_bootup_callback (unsigned short canid, unsigned char * data, unsigned char len)\fC [private]\fP"

.PP
This is the CAN boot reception callback\&. This is the reception callback assigned to the CanOPEN Boot frames\&.
.PP
NOTE: Every motor device subclassing this module receives all the incomimng frames even if they are not addressed to the given motor\&.
.PP
\fBParameters\fP
.RS 4
\fIcanid\fP 
.br
\fIdata\fP 
.br
\fIlen\fP 
.RE
.PP

.SS "void CanOpenMotor::thread_canopen_rx_sdo_callback (unsigned short canid, unsigned char * data, unsigned char len)\fC [private]\fP"

.PP
This is the CAN sdo reception callback\&. This is the reception callback assigned to the SDO register reception in the CanDriver module
.PP
The function verifies if the received address matches with the motor address in order to process the frame\&.
.PP
NOTE: Every motor device subclassing this module receives all the incomimng frames even if they are not addressed to the given motor\&.
.PP
\fBParameters\fP
.RS 4
\fIcanid\fP This is the Can ID received
.br
\fIdata\fP This is the received buffer
.br
\fIlen\fP This is the lenght of the received buffer
.RE
.PP

.SS "bool CanOpenMotor::update_external_position (void)\fC [private]\fP"

.PP
read the external sensor and fill the external data 
.SS "void CanOpenMotor::updateCurrentPosition (void)\fC [private]\fP"

.PP
This function updates the current position\&. The current position is stored in both units:
.IP "\(bu" 2
current_eposition: is the position espressed in Encoder units;
.IP "\(bu" 2
current_uposition: is the position espressed in User (application) units;
.PP

.SS "bool CanOpenMotor::uploadNanojProgram (void)\fC [private]\fP"

.PP
This function handles the Upload nanoj program steps\&. The function executes the Uploading only in the case the program is changed or it is not yet programmed\&.
.IP "\(bu" 2
The module verifies if the current program checksum is different of the sotred into the motor device\&.
.PP
.PP
The Module:
.IP "\(bu" 2
Delete the VMM flash memory in the target;
.IP "\(bu" 2
Reset the module to apply the Delete command (mandatory);
.IP "\(bu" 2
Upload blocks of 1024 bytes and stores it;
.IP "\(bu" 2
Stores the new program checksum in the USER register area;
.PP
.PP
\fBReturns\fP
.RS 4
true in case of upload success
.RE
.PP

.SH "Member Data Documentation"
.PP 
.SS "bool CANOPEN::CanOpenMotor::abort_request\fC [private]\fP"

.PP
This flag active causes an immediate command abort\&. 
.SS "bool CANOPEN::CanOpenMotor::autostart_mode\fC [private]\fP"

.PP
Set to tru if the activation ommand is automatically started\&. 
.SS "\fB_CiA402Status\fP CANOPEN::CanOpenMotor::CiA_current_status\fC [private]\fP"

.PP
CiA current detected status\&. 
.SS "int CANOPEN::CanOpenMotor::command_acc\fC [private]\fP"

.PP
Acceleration in user/s2\&. 
.SS "\fBMotorCompletedCodes\fP CANOPEN::CanOpenMotor::command_completed_code\fC [private]\fP"

.PP
Activation result\&. 
.SS "int CANOPEN::CanOpenMotor::command_dec\fC [private]\fP"

.PP
Deceleration in user/s2\&. 
.SS "int CANOPEN::CanOpenMotor::command_homing_off_method\fC [private]\fP"

.PP
Homing method whith zero photocell starting in OFF status\&. 
.SS "int CANOPEN::CanOpenMotor::command_homing_on_method\fC [private]\fP"

.PP
Homing method whith zero photocell starting in ON status\&. 
.SS "int CANOPEN::CanOpenMotor::command_id\fC [private]\fP"

.PP
ID code of the requested command\&. 
.SS "int CANOPEN::CanOpenMotor::command_ms_tmo\fC [private]\fP"

.PP
Timeout activation in ms\&. 
.SS "int CANOPEN::CanOpenMotor::command_speed\fC [private]\fP"

.PP
Speed in user/s\&. 
.SS "bool CANOPEN::CanOpenMotor::command_stop\fC [private]\fP"

.PP
Request to stop the current activation\&. 
.SS "int CANOPEN::CanOpenMotor::command_target\fC [private]\fP"

.PP
Target position in user units\&. 
.SS "System::String ^ CANOPEN::CanOpenMotor::config_param\fC [protected]\fP"

.PP
Pointer to the parameter in the config parameter 
.br
 
.SS "bool CANOPEN::CanOpenMotor::configuration_command\fC [private]\fP"

.SS "\fBMotorCommands\fP CANOPEN::CanOpenMotor::current_command\fC [private]\fP"

.PP
Current executing command code\&. 
.SS "unsigned char CANOPEN::CanOpenMotor::device_id\fC [protected]\fP"

.PP
This is the target Device Id\&. 
.SS "int CANOPEN::CanOpenMotor::encoder_eposition\fC [private]\fP"

.PP
Current Encoder position\&. 
.SS "int CANOPEN::CanOpenMotor::encoder_uposition\fC [private]\fP"

.PP
Current User position\&. 
.SS "unsigned int CANOPEN::CanOpenMotor::error_class\fC [private]\fP"

.SS "unsigned int CANOPEN::CanOpenMotor::error_code\fC [private]\fP"

.SS "bool CANOPEN::CanOpenMotor::error_condition\fC [private]\fP"

.SS "Notify::messages CANOPEN::CanOpenMotor::error_homing\fC [protected]\fP"

.SS "float CANOPEN::CanOpenMotor::external_k_coeff\fC [private]\fP"

.PP
user_position/external_raw_position coefficient 
.SS "bool CANOPEN::CanOpenMotor::external_position_mode\fC [private]\fP"

.SS "unsigned short CANOPEN::CanOpenMotor::external_raw_position\fC [private]\fP"

.PP
The current position is detected with the analog input from an external source (potentiometer) Cureent value of the potentiometer; 
.SS "int CANOPEN::CanOpenMotor::external_uposition\fC [private]\fP"

.PP
Current user position calculate from the external source\&. 
.SS "unsigned short CANOPEN::CanOpenMotor::external_zero_setting\fC [private]\fP"

.PP
Potentiometer value at mechanical zero position\&. 
.SS "bool CANOPEN::CanOpenMotor::fault_activation\fC [protected]\fP"

.SS "bool CANOPEN::CanOpenMotor::home_initialized\fC [private]\fP"

.PP
The device has executed the homing procedure 
.br
 
.SS "\fBstatus_options\fP CANOPEN::CanOpenMotor::internal_status\fC [private]\fP"

.PP
This is the current internal motor status\&. 
.SS "Thread ^ CANOPEN::CanOpenMotor::main_thread\fC [private]\fP"

.SS "int CANOPEN::CanOpenMotor::max_position\fC [private]\fP"

.PP
This is the maximum target selectable\&. 
.SS "double CANOPEN::CanOpenMotor::meanTime\fC [private]\fP"

.SS "int CANOPEN::CanOpenMotor::min_position\fC [private]\fP"

.PP
This is the minimum target selectable\&. 
.SS "\fBmotor_rotation_activations\fP CANOPEN::CanOpenMotor::motor_direction\fC [private]\fP"

.PP
The current direction of the motor activation\&. 
.SS "bool CANOPEN::CanOpenMotor::nanoj_initialized\fC [private]\fP"

.PP
Nano-J program has been intialized\&. 
.SS "bool CANOPEN::CanOpenMotor::nanoj_rx_pending\fC [private]\fP"

.PP
A SDO reception fdata is pending\&. 
.SS "int CANOPEN::CanOpenMotor::nanojSize\fC [private]\fP"

.SS "bool CANOPEN::CanOpenMotor::od_initialized\fC [private]\fP"

.PP
Object dictionary has been intialized\&. 
.SS "double CANOPEN::CanOpenMotor::perc10\fC [private]\fP"

.SS "double CANOPEN::CanOpenMotor::perc15\fC [private]\fP"

.SS "double CANOPEN::CanOpenMotor::perc20\fC [private]\fP"

.SS "double CANOPEN::CanOpenMotor::perc25\fC [private]\fP"

.SS "double CANOPEN::CanOpenMotor::perc30\fC [private]\fP"

.SS "double CANOPEN::CanOpenMotor::perc5\fC [private]\fP"

.SS "double CANOPEN::CanOpenMotor::percMeanTime\fC [private]\fP"

.SS "double CANOPEN::CanOpenMotor::percXX\fC [private]\fP"

.SS "const unsigned char* CANOPEN::CanOpenMotor::pNanoj\fC [private]\fP"

.SS "int CANOPEN::CanOpenMotor::previous_uposition\fC [private]\fP"

.PP
This is the last target position for non coordinate activations\&. 
.SS "bool CANOPEN::CanOpenMotor::read_sdo_tmo\fC [private]\fP"

.SS "\fBMotorCommands\fP CANOPEN::CanOpenMotor::request_command\fC [private]\fP"

.PP
Application request command code\&. 
.SS "bool CANOPEN::CanOpenMotor::reset_node\fC [private]\fP"

.SS "bool CANOPEN::CanOpenMotor::reverse_direction\fC [private]\fP"

.PP
Changes the polarity of the position\&. 
.SS "double CANOPEN::CanOpenMotor::rot_per_unit\fC [private]\fP"

.PP
This is the assigned Rotation/units convertion factor\&. 
.SS "bool CANOPEN::CanOpenMotor::run\fC [private]\fP"

.SS "unsigned char CANOPEN::CanOpenMotor::rxNanojAck\fC [private]\fP"

.PP
Nanoj ack byte\&. 
.SS "bool CANOPEN::CanOpenMotor::rxNanojAckValid\fC [private]\fP"

.PP
Nano-j Ack vaild\&. 
.SS "HANDLE CANOPEN::CanOpenMotor::rxSDOEvent\fC [private]\fP"

.PP
Event object signaled by the SDO receiving callback\&. 
.SS "\fBODRegister\fP ^ CANOPEN::CanOpenMotor::rxSdoRegister\fC [private]\fP"

.PP
SDO receiving data\&. 
.SS "bool CANOPEN::CanOpenMotor::sdo_rx_pending\fC [private]\fP"

.PP
A SDO reception fdata is pending\&. 
.SS "unsigned long CANOPEN::CanOpenMotor::sent_10\fC [private]\fP"

.SS "unsigned long CANOPEN::CanOpenMotor::sent_15\fC [private]\fP"

.SS "unsigned long CANOPEN::CanOpenMotor::sent_20\fC [private]\fP"

.SS "unsigned long CANOPEN::CanOpenMotor::sent_25\fC [private]\fP"

.SS "unsigned long CANOPEN::CanOpenMotor::sent_30\fC [private]\fP"

.SS "unsigned long CANOPEN::CanOpenMotor::sent_5\fC [private]\fP"

.SS "unsigned long CANOPEN::CanOpenMotor::sent_messages\fC [private]\fP"

.SS "unsigned long CANOPEN::CanOpenMotor::sent_xx\fC [private]\fP"

.SS "bool CANOPEN::CanOpenMotor::service_mode\fC [private]\fP"

.SS "bool CANOPEN::CanOpenMotor::simulator_mode\fC [protected]\fP"

.SS "const cli::array<System::String^> ^ CANOPEN::CanOpenMotor::status_tags = gcnew cli::array<System::String^> { 'NOT CONNECTED', 'CONFIGURATION', 'READY', 'BUSY', 'FAULT'}\fC [static]\fP, \fC [private]\fP"

.SS "int CANOPEN::CanOpenMotor::target_range_h\fC [private]\fP"

.PP
This is the acceptable target range in user units (upper limit) 
.SS "int CANOPEN::CanOpenMotor::target_range_l\fC [private]\fP"

.PP
This is the acceptable target range in user units (lower limit) 
.SS "double CANOPEN::CanOpenMotor::txrx_time\fC [private]\fP"

.SS "unsigned long CANOPEN::CanOpenMotor::unreceived_messages\fC [private]\fP"

.SS "bool CANOPEN::CanOpenMotor::write_sdo_tmo\fC [private]\fP"


.SH "Author"
.PP 
Generated automatically by Doxygen for MCPU_MASTER Software Description from the source code\&.
