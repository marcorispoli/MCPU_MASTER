.TH "MOTDESC" 3 "MCPU" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MOTDESC \- Motor Management Description
.SH SYNOPSIS
.br
.PP
.SH "Detailed Description"
.PP 

.SH "Index"
.PP
.SH "Abstract"
.PP
This section describes the implementation of the modules controlling the \fBGantry\fP Motors
.SH "Overview"
.PP
The \fBGantry\fP system controls five motorizations in order to accomplish with the system requirements:
.IP "\(bu" 2
Motor controlling the C-ARM Vertical position;
.IP "\(bu" 2
Motor controlling the Body position;
.IP "\(bu" 2
Motor controlling the C-ARM rotation (projections);
.IP "\(bu" 2
Motor controlling the C-ARM sliding;
.IP "\(bu" 2
Motor controlling the Tube-Arm (Tilting) rotation;
.PP

.PP
All the Motors are based on the same controlling interface:
.IP "\(bu" 2
CANOpen standard interface\&.
.PP

.PP
The Application implements a Base shared module that all the controller inherit\&.

.PP
This shared module, implement the common features that all the activation requires:
.IP "\(bu" 2
Implements the CANOpen protocol stack:
.IP "  \(bu" 4
Handles the connection with the motor device;
.IP "  \(bu" 4
Handles the CiA404 status machine;
.IP "  \(bu" 4
Handles the control of the motor register parameters;
.IP "  \(bu" 4
Handles the control of the motor activation;
.IP "  \(bu" 4
Handles the Fault management;
.PP

.IP "\(bu" 2
Implements the basic activation functions;
.IP "  \(bu" 4
Manual Activation mode;
.IP "  \(bu" 4
Automatic Activation mode;
.IP "  \(bu" 4
Automatic Zero Setting procedure;
.PP

.IP "\(bu" 2
Implements the basic safety functions;
.IP "  \(bu" 4
Manage the activation timeouts;
.IP "  \(bu" 4
Manage the obstacle detection;
.IP "  \(bu" 4
Manage the diagnostic on the position sensor;
.PP

.PP

.PP
The communication with the Motor Drivers makes use of the USB to CAN converter device, that the application handles with a dedicated internal process, providing an application common interface to send and receive frames from the CAN bus\&.
.SH "Common Features Description"
.PP
.SS "Motor Internal Status"
The Motor internal status machine is managed so that the Application can have a feedback on the current working status\&.

.PP
A common status description helps the Application to provide a standard front-end when requesting to activate one of the available motors\&.

.PP
Actually the standard internal status flags are (\fBstatus_options\fP):
.IP "\(bu" 2
NOT_CONNECTED: the dirver is not connected to the Can Bus (maybe off, disconnected);
.IP "\(bu" 2
MOTOR_CONFIGURATION: this is the startup fase;
.IP "\(bu" 2
MOTOR_READY: the motor is ready to process activations;
.IP "\(bu" 2
MOTOR_BUSY: an activation is pending;
.IP "\(bu" 2
MOTOR_FAULT: the Motor is in Fault condition

.PP
NOTE: The motor fault condition it is not necessarily a System fault\&. For example, during a compression the motor power supply is switched off for safety reason, and the motor device activate amn internal fault due to the missing power supply\&.
.PP
.SS "Motor Device Connection"
The initial startup fase is commonly handled by the Base module in order to establish a valid connection with the target motor device\&.

.PP
During the startup fase:
.IP "\(bu" 2
The Can connection is established;
.IP "\(bu" 2
The Motor is configured (see the Motor Device Configuration section) with a set of common registers;
.IP "\(bu" 2
Every Motor is configured with a subset of registers that depend by the target motor;
.IP "\(bu" 2
The current motor position is initialized (either if it is an external sensor or the device internal incremental encoder);
.PP

.PP
The Startup fase never ends until the previous steps are not successfully completed\&.

.PP
When the startup fase completes successfully, the application base module handle the internal status machine so that it is automatically set to Ready status\&.

.PP
In the event of fault condition, the application tries automatically to reset the fault as soon as the fault event disappear\&.
.SS "Motor Device Configuration"
There are basically three kind of motor configurations:
.IP "\(bu" 2
the motor control setup;
.IP "\(bu" 2
the basic motor configuration;
.IP "\(bu" 2
the performance of the motor activations\&.
.PP
.SS "Motor Control Setup"
The motor can be configured to use an external sensor or the internal Encoder:
.IP "\(bu" 2
If the motor is configured with the internal encoder:
.IP "  \(bu" 4
the position is initialized reading the actual position stored into the \fBMotorCalibration\&.cnf configuration file\fP;
.IP "  \(bu" 4
the current position is then totally internally managed be the motor device;
.PP

.IP "\(bu" 2
If the motor is configured with the external sensor:
.IP "  \(bu" 4
the position is initialized reading the external sensor and initializing the internal encoder with the sensor;
.IP "  \(bu" 4
external sensor (potentiometer) shall be calibrated;
.IP "  \(bu" 4
the calibrated parameters are stored into the \fBMotorCalibration\&.cnf configuration file\fP;
.PP

.PP
See the Position contro section for detail\&.
.PP

.PP
During the startup fase every Motor can upload (if needed) a special program (Nano-J application) running inside the device for special functions\&.

.PP
See the detail of every motor description\&.
.SS "Basic Motor Configurations"
Every motor sets its own subset of parameters to tune the reaction of that motor propery, with respect of the mechanical asset and its required performances\&.

.PP
The parameters that usually are set into this fase are:

.PP
.IP "\(bu" 2
The Maximum Current per fase;
.IP "\(bu" 2
The Maximum speed;
.IP "\(bu" 2
The Maximum acceleration;
.IP "\(bu" 2
The Position limits;
.IP "\(bu" 2
The PID parameters;
.IP "\(bu" 2
The GPIO configuration;
.PP

.PP
During the Startup fase, every implemented motor controller is requested to upload its subset of registers\&.
.SS "Performances"
Every motor can set its own performances reading the content of the \fBMotorCalibration\&.cnf configuration file\fP\&.

.PP
The following parameters can dinamically be configured:
.IP "\(bu" 2
The Automatic activation speed, acceleration, deceleration parameters;
.IP "\(bu" 2
The Manual activation speed, acceleration, deceleration parameters;
.IP "\(bu" 2
The Automatic (if necessary) Zero setting speed and acceleration;
.PP

.PP
Those parameters can be changed runtime after the application is compiled\&.
.SS "Position Handling"
Every motor control can be configured to use only the internal incremental encoder or an external potentiometer, connected to the Analog Input of the motor device\&.

.PP
See the \fBMotorCalibration\&.cnf configuration file\fP description for details\&.
.SS "Internal Incremental Encoder Mode"
When the motor control setup is set to use only the internal encoder, the actual position is handled internally by the motor device\&.

.PP
Because the internal position is reset after every power off, in order to keep a valid absolute position, after every activation completion, the actual position is stored into the \fBMotorConfig:\fP
.IP "\(bu" 2
During the startup fase, the actual position is then retrived from the configuration file\&.
.PP

.PP
In case of file corruption, first istallation, or whenever the position should be considered no more valid, a special automatic or manual zero setting procedure can be requested:
.IP "\(bu" 2
a new valid actual position is then acquiored and stored into the configuration file\&.
.PP

.PP
See the Zero Setting Management section for details\&.
.SS "External Position Sensor"
If the motor control is configured to make use of an external position sensor as a reference, this sensor is used in the startup fase in order to initialize the internal encoder with the actual absolute position\&.

.PP
The position then will be handled as in the Internal Incremental Encoder Mode\&.

.PP
In order to be used, however, the external sensor position shall be calibrated:
.IP "\(bu" 2
the calibration consists to store the sensor readout value corresponding to the virtual zero position\&.
.PP

.PP
The calibration is executed with a proper panel in the Service Tool (see the related documentation)\&.

.PP
Without a valid calibration, the motor module sets a proper Warning message, preventing any operative activation (but enabling the Service Activation for service purpose)\&.
.SS "Fault Management"
Every motor control module handles the Faults signalled by the Motor Device\&.

.PP
An active Fault status always prevents to activate the given motorization\&.

.PP
The Application reads the current fault code from the remote motor device, logging it into the Gantry\&.log file:
.IP "\(bu" 2
A generic application Warning message will be activated and displayed in the Message Panel Window;
.PP

.PP
The application automatically will retry to exits from the Fault status:
.IP "\(bu" 2
in the case the fault condition should clear, the normal motor operation will be restored\&.
.PP

.PP
If a Fault condition should happen during any activation mode, the activation will be quickly aborted\&.
.SS "Obstacle Detection"
Every motor controller share the same mechanism to handle the obstacle detection:
.IP "\(bu" 2
the Application, based on the current operating mode, assignes the obstacle triggers to the current motor ativated\&.
.PP

.PP
When the obstacle is triggered, if a motor is activated immediatelly stops\&.

.PP
The Obstacle detection is active only for the Automatic activations\&. 
.PP
.nf
NOTE: the manual activation, for its intrinsic safety, doesn't require the obstacle detection\&.

.fi
.PP

.PP
See the specific Motor function section for detailed description about the obstacle detection\&.
.SS "Manual Activation Button management"
Every motor control module inherits a shared mechanism to check the activation of system IOs that the Application, in a similar way as it mades for the obstacle triggers, assignes to be a manual activation triggers\&.

.PP
During every operating status, the motor control checks the status of the manual triggers, and if they are enabled by the application, they causes the following reaction:
.IP "\(bu" 2
If the motor is in Idle, a manual activation is started;
.IP "\(bu" 2
If the motor is running with an automatic activation, the activation stops;
.PP

.PP
The Application may enable or disable the manual triggers individually for any motor based on the current operating contest\&.

.PP
See the description of the given motor control for details\&.
.SS "Customization preparation and termination procedures"
Every motor controller module inherits a shared method to customize the activation preparation and termination:

.PP
.IP "\(bu" 2
During the preparation of the motor activation, just after having applied the torque, the controller module of the activating motor receives a call to a special function in order to let that module to prepare for the activation: for example in case of stationary brake, it has to be released before to start\&.
.IP "\(bu" 2
The similar method is used to terminates an activation: just before to remove the torque, the controller of the terminating motor receives a call to a specific termination procedure: in the case of the brakes, for example, the stationary brake shall be activated\&.
.PP

.PP
See the specific motor function implementation for details\&.
.SS "Automatic Position Activation"
Every motor inherits this basic activation mode\&.

.PP
The Automatic activation allows the motor control module to set a particolar target, to set the activation parameters (speed, acceleration, deceleration) and to wait for the command completion\&.

.PP
During the activation:
.IP "\(bu" 2
if the obstacle is detected, the activation quickly stops;
.IP "\(bu" 2
if the manual activation is triggered, the activation quickly stops;
.IP "\(bu" 2
If a fault condition is detected, the activation quickly stops;
.PP

.PP
The activation successfully termines when:
.IP "\(bu" 2
the motor device detect the target position;
.IP "\(bu" 2
the control module detects that the current position is in an acceptable target range for almost one second;

.PP
NOTE: although the motor device should handle the activation completion, the module always check the current position to prevent a system lock if the motor driver should fail in monitoring the target range\&.
.PP

.PP
There are two type of automatic activations:
.IP "\(bu" 2
an automatic starting activation: the motor starts running after motor preparation;
.IP "\(bu" 2
a nano-j start: the motor is prepared for the activation, and a special program is loaded into the motor\&. The program, should activate the motor when the start condition are detected\&.
.PP

.PP
See the specific motor function implementation for details\&.
.SS "Manual Position Activation"
Every motor controller inherits the the Manual position activation mode\&.

.PP
The manual position activate the motor when the manual activation triggers are detected active\&.

.PP
The direction of motor rotation is assigned by the application to the triggers\&.

.PP
The motor will continue to run until:
.IP "\(bu" 2
the limit position is detected;
.IP "\(bu" 2
the manual trigger are released;
.IP "\(bu" 2
the manual triggers of the opposed direction is activated;
.PP
.SS "Zero Setting Management"
The controller modules inherit the procedure to initialize the absolute position to a known mechanical position\&.

.PP
There are two zero setting procedures:
.IP "\(bu" 2
the zero setting procedure with the external trigger;
.IP "\(bu" 2
the zero setting istant procedure, without motor rotation;
.PP
.SS "Zero setting automatic procedure with external trigger"
This procedure makes use of an external trigger, usually a photocell, in order to detect the mechanical zero position\&.

.PP
When the procedure is activated, the motor starts rotating until detect the trigger activation\&. The activation immediatelly termines and the actual position is updated with the real mechanical position\&. The current position is then stored into the \fBMotorCalibration\&.cnf configuration file\fP file\&.

.PP
During the zero setting activation:
.IP "\(bu" 2
the obstacle detection is monitored: the zero setting is aborted in the case they should detected;
.IP "\(bu" 2
the manual activatin triggers are monitored: the zero setting is aborted in the case they should detected;

.PP
NOTE: during the zero setting procedure, the limit position register is ignored\&.
.PP
.SS "Zero setting istant procedure"
This procedure can be activated when the current absolute position is known: the encoder is istantly initialized with the actual position, without to start the rotation\&.

.PP
This procedure is internally used by the innher module of every motor controller in case it is using an external position sensor: in this case, at the startup, the actual position is provided by the current value of the sensor\&.

.PP
.SH "Motor Functions detailed desciption"
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for MCPU from the source code\&.
